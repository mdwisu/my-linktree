---
// MusicPlayer.astro
---

<div class="fixed bottom-4 right-4 z-50" id="music-player-container">
  <!-- Toggle Button with visual indicator -->
  <button
    id="music-toggle"
    type="button"
    class="music-toggle-btn"
    aria-label="Toggle music player"
    aria-expanded="false"
    aria-controls="music-panel"
  >
    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
    </svg>
    <!-- Playing indicator -->
    <div id="playing-indicator" class="absolute -top-1 -right-1 w-3 h-3 bg-green-500 rounded-full animate-pulse hidden"></div>
    <span class="sr-only">Music Player</span>
  </button>

  <!-- Music Player Panel -->
  <div
    id="music-panel"
    class="music-panel music-panel--closed"
    role="dialog"
    aria-label="Music player controls"
    aria-hidden="true"
  >
    <!-- Current Song Info -->
    <div class="song-info">
      <div class="album-art">
        <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
        </svg>
      </div>
      <div class="song-details">
        <h4 id="song-title" class="song-title" aria-live="polite">
          Loading music...
        </h4>
        <p id="song-artist" class="song-artist" aria-live="polite">
          Please wait
        </p>
      </div>
    </div>

    <!-- Progress Section -->
    <div class="progress-section">
      <div class="time-display">
        <time id="current-time" class="time-text">0:00</time>
        <time id="total-time" class="time-text">0:00</time>
      </div>
      <div 
        id="progress-container" 
        class="progress-container"
        role="slider"
        aria-label="Seek position"
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow="0"
        tabindex="0"
      >
        <div id="progress-bar" class="progress-bar"></div>
      </div>
    </div>

    <!-- Control Buttons -->
    <div class="controls-section" role="group" aria-label="Playback controls">
      <button
        id="prev-btn"
        type="button"
        class="control-btn"
        aria-label="Previous track"
      >
        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
        </svg>
      </button>

      <button
        id="play-pause-btn"
        type="button"
        class="play-pause-btn"
        aria-label="Play music"
        data-state="paused"
      >
        <svg id="play-icon" class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M8 5v14l11-7z"/>
        </svg>
        <svg id="pause-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
        </svg>
      </button>

      <button
        id="next-btn"
        type="button"
        class="control-btn"
        aria-label="Next track"
      >
        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
        </svg>
      </button>
    </div>

    <!-- Volume Control -->
    <div class="volume-section">
      <label for="volume-slider" class="sr-only">Volume control</label>
      <svg class="volume-icon" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
      </svg>
      <input
        type="range"
        id="volume-slider"
        class="volume-slider"
        min="0"
        max="100"
        value="50"
        step="1"
        aria-label="Volume"
      />
    </div>

    <!-- Status Display -->
    <div class="status-section">
      <span id="music-status" class="status-text" aria-live="polite" aria-atomic="true">
        Initializing...
      </span>
    </div>

    <!-- Autoplay Info -->
    <div id="autoplay-info" class="text-xs text-center mt-2 text-gray-500 dark:text-gray-400">
      Click anywhere to enable audio
    </div>
  </div>
</div>

<!-- Raining Tacos Animation Container -->
<div id="tacos-rain-container" class="tacos-rain-container hidden">
  <!-- Tacos will be dynamically added here -->
</div>

<!-- Load Howler.js from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>

<script>
// TypeScript interface declarations
interface Track {
  readonly id: string;
  readonly title: string;
  readonly artist: string;
  readonly src: string;
  readonly duration: number;
}

interface Elements {
  toggle: HTMLElement | null;
  panel: HTMLElement | null;
  songTitle: HTMLElement | null;
  songArtist: HTMLElement | null;
  currentTime: HTMLElement | null;
  totalTime: HTMLElement | null;
  progressContainer: HTMLElement | null;
  progressBar: HTMLElement | null;
  prevBtn: HTMLElement | null;
  playPauseBtn: HTMLElement | null;
  nextBtn: HTMLElement | null;
  volumeSlider: HTMLInputElement | null;
  musicStatus: HTMLElement | null;
  playIcon: HTMLElement | null;
  pauseIcon: HTMLElement | null;
  playingIndicator: HTMLElement | null;
  autoplayInfo: HTMLElement | null;
}

// Howler.js type declaration (basic)
declare class Howl {
  constructor(options: any);
  play(): number;
  pause(): this;
  stop(): this;
  volume(vol?: number): number | this;
  seek(position?: number): number | this;
  duration(): number;
  unload(): this;
  on(event: string, callback: Function): this;
  state(): string;
}

class HowlerMusicPlayer {
  private currentIndex: number;
  private isPlaying: boolean;
  private isPanelOpen: boolean;
  private userHasInteracted: boolean;
  private autoplayAttempted: boolean;
  private volume: number;
  private currentSound: Howl | null;
  private progressInterval: number | null;
  private playlist: Track[];
  private elements: Elements;
  private tacosRainInterval: number | null;
  private activeTacos: HTMLElement[];
  private isMobile: boolean;
  private scrollTimeout: number | null;
  private lastScrollTime: number;
  private audioContext: AudioContext | null;
  private isContextSuspended: boolean;
  private retryCount: number;
  private maxRetries: number;

  constructor() {
    this.currentIndex = 0;
    this.isPlaying = false;
    this.isPanelOpen = false;
    this.userHasInteracted = false;
    this.autoplayAttempted = false;
    this.volume = 0.5;
    this.currentSound = null;
    this.progressInterval = null;
    this.tacosRainInterval = null;
    this.activeTacos = [];
    this.isMobile = this.detectMobile();
    this.scrollTimeout = null;
    this.lastScrollTime = 0;
    this.audioContext = null;
    this.isContextSuspended = false;
    this.retryCount = 0;
    this.maxRetries = 3;
    
    // Playlist configuration
    this.playlist = [
      {
              id: 'tacos-1',
              title: 'Raining Tacos',
              artist: 'Parry Gripp & BooneBum',
              src: '/music/raining-tacos.mp3',
              duration: 180
          },
          {
              id: 'lofi-1',
              title: 'Lofi Hip Hop Beat',
              artist: 'Chill Vibes',
              src: '/music/lofi-beat.mp3',
              duration: 180
          }
    ];

    // Initialize elements object
    this.elements = {
      toggle: null,
      panel: null,
      songTitle: null,
      songArtist: null,
      currentTime: null,
      totalTime: null,
      progressContainer: null,
      progressBar: null,
      prevBtn: null,
      playPauseBtn: null,
      nextBtn: null,
      volumeSlider: null,
      musicStatus: null,
      playIcon: null,
      pauseIcon: null,
      playingIndicator: null,
      autoplayInfo: null
    };

    this.init();
  }

  private detectMobile(): boolean {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
           (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform));
  }

  private async init(): Promise<void> {
    try {
      this.cacheElements();
      this.setupEventListeners();
      this.setupMobileOptimizations();
      this.setupAutoplayDetection();
      this.loadTrack(this.currentIndex);
      this.updateUI();
      this.ensurePanelClosed();
      
      console.log('üéµ Howler Music Player Initialized');
      console.log('üì± Mobile device detected:', this.isMobile);
      console.log('üîä Autoplay will trigger after user interaction');
      
    } catch (error) {
      console.error('Failed to initialize music player:', error);
      this.handleError('Failed to initialize player');
    }
  }

  private setupMobileOptimizations(): void {
    if (!this.isMobile) return;

    // Mobile-specific audio context management
    this.setupAudioContextManagement();
    
    // Mobile scroll handling
    this.setupScrollHandling();
    
    // Visibility change handling for mobile
    this.setupVisibilityHandling();
    
    // Page lifecycle handling
    this.setupPageLifecycleHandling();

    console.log('üì± Mobile optimizations applied');
  }

  private setupAudioContextManagement(): void {
    // Monitor audio context state
    const checkAudioContext = () => {
      if (this.currentSound && (this.currentSound as any)._audioContext) {
        const context = (this.currentSound as any)._audioContext;
        
        if (context.state === 'suspended' && !this.isContextSuspended) {
          this.isContextSuspended = true;
          console.log('üîá Audio context suspended');
          
          // Try to resume context when user interacts again
          this.setupContextResume();
        } else if (context.state === 'running' && this.isContextSuspended) {
          this.isContextSuspended = false;
          console.log('üîä Audio context resumed');
        }
      }
    };

    setInterval(checkAudioContext, 1000);
  }

  private setupContextResume(): void {
    const resumeContext = async () => {
      if (this.currentSound && (this.currentSound as any)._audioContext) {
        const context = (this.currentSound as any)._audioContext;
        
        if (context.state === 'suspended') {
          try {
            await context.resume();
            console.log('‚úÖ Audio context resumed successfully');
            
            // Restart playback if it was playing
            if (this.isPlaying) {
              setTimeout(() => {
                this.handlePlaybackResume();
              }, 100);
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Failed to resume audio context:', error);
          }
        }
      }
    };

    // Try to resume on various user interactions
    const events = ['touchstart', 'touchend', 'click', 'keydown'];
    const handler = () => {
      resumeContext();
      // Remove listeners after first successful resume
      events.forEach(event => {
        document.removeEventListener(event, handler);
      });
    };

    events.forEach(event => {
      document.addEventListener(event, handler, { once: true, passive: true });
    });
  }

  private setupScrollHandling(): void {
    let isScrolling = false;
    
    const handleScroll = () => {
      if (!this.isMobile || !this.isPlaying) return;
      
      const now = Date.now();
      this.lastScrollTime = now;
      
      if (!isScrolling) {
        isScrolling = true;
        // Don't pause immediately, wait for scroll to finish
      }
      
      // Clear existing timeout
      if (this.scrollTimeout) {
        clearTimeout(this.scrollTimeout);
      }
      
      // Set timeout to handle end of scroll
      this.scrollTimeout = window.setTimeout(() => {
        isScrolling = false;
        
        // Check if audio is still playing after scroll
        if (this.isPlaying && this.currentSound) {
          this.verifyPlaybackState();
        }
      }, 150); // Wait 150ms after scroll stops
    };

    // Use passive listeners for better performance
    document.addEventListener('scroll', handleScroll, { passive: true });
    document.addEventListener('touchmove', handleScroll, { passive: true });
  }

  private setupVisibilityHandling(): void {
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Page is hidden
        if (this.isPlaying) {
          console.log('üì± Page hidden, maintaining playback state');
        }
      } else {
        // Page is visible again
        if (this.isPlaying) {
          setTimeout(() => {
            this.verifyPlaybackState();
          }, 500);
        }
      }
    });
  }

  private setupPageLifecycleHandling(): void {
    // Handle page freeze/resume (mobile Safari)
    window.addEventListener('pagehide', () => {
      if (this.isPlaying) {
        console.log('üì± Page hiding, saving state');
      }
    });

    window.addEventListener('pageshow', (event) => {
      if (event.persisted && this.isPlaying) {
        // Page restored from cache
        setTimeout(() => {
          this.verifyPlaybackState();
        }, 500);
      }
    });

    // Handle app backgrounding
    window.addEventListener('blur', () => {
      if (this.isMobile && this.isPlaying) {
        // App going to background
        setTimeout(() => {
          this.verifyPlaybackState();
        }, 1000);
      }
    });

    window.addEventListener('focus', () => {
      if (this.isMobile && this.isPlaying) {
        // App coming to foreground
        setTimeout(() => {
          this.verifyPlaybackState();
        }, 500);
      }
    });
  }

  private async verifyPlaybackState(): Promise<void> {
    if (!this.currentSound || !this.isPlaying) return;

    try {
      // Check if sound is actually playing
      const isActuallyPlaying = this.currentSound.state() === 'loaded' && 
                               (this.currentSound as any).playing();

      if (!isActuallyPlaying && this.isPlaying) {
        console.log('üîß Detected playback interruption, attempting recovery');
        await this.recoverPlayback();
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Error verifying playback state:', error);
      this.handlePlaybackError(error);
    }
  }

  private async recoverPlayback(): Promise<void> {
    if (this.retryCount >= this.maxRetries) {
      console.error('‚ùå Max retry attempts reached');
      this.handlePlaybackFailure();
      return;
    }

    this.retryCount++;
    console.log(`üîÑ Recovery attempt ${this.retryCount}/${this.maxRetries}`);

    try {
      // Stop current sound
      if (this.currentSound) {
        this.currentSound.stop();
      }

      // Wait a bit
      await new Promise(resolve => setTimeout(resolve, 200));

      // Try to resume audio context if needed
      if (this.currentSound && (this.currentSound as any)._audioContext) {
        const context = (this.currentSound as any)._audioContext;
        if (context.state === 'suspended') {
          await context.resume();
        }
      }

      // Restart playback
      await this.play();
      
      if (this.isPlaying) {
        console.log('‚úÖ Playback recovered successfully');
        this.retryCount = 0; // Reset retry count on success
        this.updateStatus('Playback recovered');
      }

    } catch (error) {
      console.warn(`‚ö†Ô∏è Recovery attempt ${this.retryCount} failed:`, error);
      
      if (this.retryCount < this.maxRetries) {
        // Try again after a longer delay
        setTimeout(() => {
          this.recoverPlayback();
        }, 1000 * this.retryCount);
      } else {
        this.handlePlaybackFailure();
      }
    }
  }

  private handlePlaybackResume(): void {
    if (this.currentSound && this.isPlaying) {
      try {
        this.currentSound.play();
        console.log('üéµ Playback resumed after context recovery');
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to resume playback:', error);
        this.recoverPlayback();
      }
    }
  }

  private handlePlaybackError(error: any): void {
    console.error('üö® Playback error:', error);
    
    if (this.isMobile) {
      this.updateStatus('Playback interrupted');
      
      // Try recovery
      setTimeout(() => {
        this.recoverPlayback();
      }, 500);
    } else {
      this.handleError('Playback failed');
    }
  }

  private handlePlaybackFailure(): void {
    this.isPlaying = false;
    this.updatePlayButton();
    this.hidePlayingIndicator();
    this.stopProgressTracking();
    this.updateStatus('Playback failed - tap play to retry');
    this.retryCount = 0;
    
    // Show user-friendly message
    this.showToast('Audio interrupted. Tap play to resume.');
  }

  private cacheElements(): void {
    this.elements = {
      toggle: document.getElementById('music-toggle'),
      panel: document.getElementById('music-panel'),
      songTitle: document.getElementById('song-title'),
      songArtist: document.getElementById('song-artist'),
      currentTime: document.getElementById('current-time'),
      totalTime: document.getElementById('total-time'),
      progressContainer: document.getElementById('progress-container'),
      progressBar: document.getElementById('progress-bar'),
      prevBtn: document.getElementById('prev-btn'),
      playPauseBtn: document.getElementById('play-pause-btn'),
      nextBtn: document.getElementById('next-btn'),
      volumeSlider: document.getElementById('volume-slider') as HTMLInputElement,
      musicStatus: document.getElementById('music-status'),
      playIcon: document.getElementById('play-icon'),
      pauseIcon: document.getElementById('pause-icon'),
      playingIndicator: document.getElementById('playing-indicator'),
      autoplayInfo: document.getElementById('autoplay-info')
    };
  }

  private setupEventListeners(): void {
    // Panel toggle
    this.elements.toggle?.addEventListener('click', () => {
      this.markUserInteraction();
      this.togglePanel();
    });

    // Play/Pause
    this.elements.playPauseBtn?.addEventListener('click', () => {
      this.markUserInteraction();
      this.togglePlayback();
    });

    // Navigation
    this.elements.prevBtn?.addEventListener('click', () => {
      this.markUserInteraction();
      this.previousTrack();
    });

    this.elements.nextBtn?.addEventListener('click', () => {
      this.markUserInteraction();
      this.nextTrack();
    });

    // Volume
    this.elements.volumeSlider?.addEventListener('input', (e: Event) => {
      const target = e.target as HTMLInputElement;
      this.setVolume(Number(target.value) / 100);
    });

    // Progress
    this.elements.progressContainer?.addEventListener('click', (e: Event) => {
      this.handleProgressClick(e as MouseEvent);
    });

    // Outside click
    document.addEventListener('click', (e: Event) => {
      this.handleOutsideClick(e);
    });
  }

  private setupAutoplayDetection(): void {
    // Track user interaction for autoplay
    const interactionEvents = ['click', 'keydown', 'touchstart', 'mousedown'];
    
    const handleInteraction = () => {
      if (!this.userHasInteracted) {
        this.markUserInteraction();
        
        // Attempt autoplay after short delay
        setTimeout(() => {
          if (!this.autoplayAttempted) {
            this.attemptAutoplay();
          }
        }, 300);
      }
    };

    interactionEvents.forEach(event => {
      document.addEventListener(event, handleInteraction, { once: true });
    });
  }

  private markUserInteraction(): void {
    if (!this.userHasInteracted) {
      this.userHasInteracted = true;
      this.hideAutoplayInfo();
      console.log('üéØ User interaction detected - autoplay enabled');
    }
  }

  private async attemptAutoplay(): Promise<void> {
    if (this.autoplayAttempted || this.isPlaying) return;
    
    this.autoplayAttempted = true;
    
    try {
      // Wait a bit for UI to settle
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Start playing
      await this.play();
      
      if (this.isPlaying) {
        this.updateStatus('Auto-playing...');
        console.log('‚úÖ Autoplay successful');
      }
      
    } catch (error) {
      console.warn('‚ö†Ô∏è Autoplay failed:', error);
      this.updateStatus('Click play to start');
      this.showAutoplayInfo();
    }
  }

  private loadTrack(index: number): void {
    if (index < 0 || index >= this.playlist.length) return;

    const track = this.playlist[index];
    this.currentIndex = index;

    // Stop current sound if playing
    if (this.currentSound) {
      this.currentSound.stop();
      this.currentSound.unload();
    }

    // Reset retry count for new track
    this.retryCount = 0;

    // Create new Howl instance with mobile optimizations
    this.currentSound = new Howl({
      src: [track.src],
      volume: this.volume,
      preload: true,
      html5: this.isMobile, // Force HTML5 Audio for mobile
      pool: 1, // Limit pool size for mobile
      onload: () => {
        this.updateStatus('Ready to play');
        this.updateTrackInfo(track);
        this.updateTotalTime();
      },
      onloaderror: (id: number, error: any) => {
        console.error('Load error:', error);
        this.handleError(`Failed to load: ${track.title}`);
      },
      onplay: () => {
        this.isPlaying = true;
        this.updatePlayButton();
        this.showPlayingIndicator();
        this.updateStatus('Playing');
        this.startProgressTracking();
        this.checkTacosRain(track);
      },
      onpause: () => {
        this.isPlaying = false;
        this.updatePlayButton();
        this.hidePlayingIndicator();
        this.updateStatus('Paused');
        this.stopProgressTracking();
        this.stopTacosRain();
      },
      onstop: () => {
        this.isPlaying = false;
        this.updatePlayButton();
        this.hidePlayingIndicator();
        this.updateStatus('Stopped');
        this.stopProgressTracking();
        this.stopTacosRain();
      },
      onend: () => {
        this.handleTrackEnded();
      },
      onplayerror: (id: number, error: any) => {
        console.error('Play error:', error);
        this.handlePlaybackError(error);
      }
    });

    this.updateTrackInfo(track);
  }

  private async play(): Promise<void> {
    if (!this.currentSound) {
      this.loadTrack(this.currentIndex);
      return;
    }

    try {
      // Reset retry count on manual play
      this.retryCount = 0;
      this.currentSound.play();
    } catch (error) {
      console.error('Play failed:', error);
      this.handlePlaybackError(error);
      throw error;
    }
  }

  private pause(): void {
    if (this.currentSound) {
      this.currentSound.pause();
    }
  }

  private stop(): void {
    if (this.currentSound) {
      this.currentSound.stop();
    }
  }

  private async togglePlayback(): Promise<void> {
    if (this.isPlaying) {
      this.pause();
    } else {
      await this.play();
    }
  }

  private previousTrack(): void {
    const newIndex = this.currentIndex > 0 
      ? this.currentIndex - 1 
      : this.playlist.length - 1;
    
    const wasPlaying = this.isPlaying;
    this.loadTrack(newIndex);
    
    if (wasPlaying && this.userHasInteracted) {
      setTimeout(() => this.play(), 100);
    }
  }

  private nextTrack(): void {
    const newIndex = (this.currentIndex + 1) % this.playlist.length;
    const wasPlaying = this.isPlaying;
    this.loadTrack(newIndex);
    
    if (wasPlaying && this.userHasInteracted) {
      setTimeout(() => this.play(), 100);
    }
  }

  private setVolume(volume: number): void {
    this.volume = Math.max(0, Math.min(1, volume));
    if (this.currentSound) {
      this.currentSound.volume(this.volume);
    }
    
    // Update slider
    if (this.elements.volumeSlider) {
      this.elements.volumeSlider.value = (this.volume * 100).toString();
    }
  }

  private handleTrackEnded(): void {
    this.isPlaying = false;
    this.updatePlayButton();
    this.hidePlayingIndicator();
    this.stopTacosRain();
    
    // Auto-advance if user has interacted
    if (this.userHasInteracted) {
      setTimeout(() => this.nextTrack(), 500);
    }
  }

  private handleProgressClick(e: MouseEvent): void {
    if (!this.currentSound || !this.currentSound.duration()) return;

    const rect = e.currentTarget!.getBoundingClientRect();
    const percentage = (e.clientX - rect.left) / rect.width;
    const newTime = percentage * this.currentSound.duration();
    
    this.currentSound.seek(Math.max(0, Math.min(this.currentSound.duration(), newTime)));
  }

  private startProgressTracking(): void {
    this.stopProgressTracking();
    this.progressInterval = window.setInterval(() => {
      this.updateProgress();
    }, 1000);
  }

  private stopProgressTracking(): void {
    if (this.progressInterval) {
      clearInterval(this.progressInterval);
      this.progressInterval = null;
    }
  }

  private updateProgress(): void {
    if (!this.currentSound) return;
    
    const currentTime = this.currentSound.seek() || 0;
    const duration = this.currentSound.duration() || 0;
    
    if (duration > 0) {
      const percentage = (currentTime / duration) * 100;
      
      if (this.elements.progressBar) {
        this.elements.progressBar.style.width = `${percentage}%`;
      }
      
      if (this.elements.currentTime) {
        this.elements.currentTime.textContent = this.formatTime(currentTime);
      }
    }
  }

  private updateTotalTime(): void {
    if (this.currentSound && this.elements.totalTime) {
      const duration = this.currentSound.duration() || 0;
      this.elements.totalTime.textContent = this.formatTime(duration);
    }
  }

  private updateTrackInfo(track: Track): void {
    if (this.elements.songTitle) {
      this.elements.songTitle.textContent = track.title;
    }
    if (this.elements.songArtist) {
      this.elements.songArtist.textContent = track.artist;
    }
  }

  private updatePlayButton(): void {
    const playBtn = this.elements.playPauseBtn;
    const playIcon = this.elements.playIcon;
    const pauseIcon = this.elements.pauseIcon;
    
    if (!playBtn || !playIcon || !pauseIcon) return;
    
    playBtn.setAttribute('aria-label', this.isPlaying ? 'Pause' : 'Play');
    playBtn.setAttribute('data-state', this.isPlaying ? 'playing' : 'paused');
    
    playIcon.classList.toggle('hidden', this.isPlaying);
    pauseIcon.classList.toggle('hidden', !this.isPlaying);
  }

  private updateStatus(message: string): void {
    if (this.elements.musicStatus) {
      this.elements.musicStatus.textContent = message;
    }
  }

  private updateUI(): void {
    this.updateTrackInfo(this.playlist[this.currentIndex]);
    this.updatePlayButton();
    this.updateProgress();
    if (this.elements.volumeSlider) {
      this.elements.volumeSlider.value = (this.volume * 100).toString();
    }
  }

  private showPlayingIndicator(): void {
    if (this.elements.playingIndicator) {
      this.elements.playingIndicator.classList.remove('hidden');
    }
  }

  private hidePlayingIndicator(): void {
    if (this.elements.playingIndicator) {
      this.elements.playingIndicator.classList.add('hidden');
    }
  }

  private showAutoplayInfo(): void {
    if (this.elements.autoplayInfo) {
      this.elements.autoplayInfo.classList.remove('hidden');
    }
  }

  private hideAutoplayInfo(): void {
    if (this.elements.autoplayInfo) {
      this.elements.autoplayInfo.classList.add('hidden');
    }
  }

  private togglePanel(): void {
    if (this.isPanelOpen) {
      this.closePanel();
    } else {
      this.openPanel();
    }
  }

  private openPanel(): void {
    if (!this.elements.panel || !this.elements.toggle) return;
    
    this.isPanelOpen = true;
    
    this.elements.panel.classList.remove('music-panel--closed');
    this.elements.panel.classList.add('music-panel--open');
    this.elements.panel.setAttribute('aria-hidden', 'false');
    this.elements.toggle.setAttribute('aria-expanded', 'true');
  }

  private closePanel(): void {
    if (!this.elements.panel || !this.elements.toggle) return;
    
    this.isPanelOpen = false;
    
    this.elements.panel.classList.remove('music-panel--open');
    this.elements.panel.classList.add('music-panel--closed');
    this.elements.panel.setAttribute('aria-hidden', 'true');
    this.elements.toggle.setAttribute('aria-expanded', 'false');
  }

  private ensurePanelClosed(): void {
    this.isPanelOpen = false;
    this.closePanel();
  }

  private handleOutsideClick(e: Event): void {
    const container = document.getElementById('music-player-container');
    if (container && !container.contains(e.target as Node) && this.isPanelOpen) {
      this.closePanel();
    }
  }

  private handleError(message: string): void {
    this.updateStatus(`Error: ${message}`);
    this.showToast(message);
  }

  private showToast(message: string): void {
    // Remove existing toasts
    document.querySelectorAll('.music-toast').forEach(toast => toast.remove());
    
    const toast = document.createElement('div');
    toast.className = 'music-toast';
    toast.textContent = message;
    toast.setAttribute('role', 'alert');
    
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.remove();
    }, 4000);
  }

  private formatTime(seconds: number): string {
    if (!seconds || isNaN(seconds)) return '0:00';
    
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  // Tacos Rain Animation Methods
  private checkTacosRain(track: Track): void {
    // Check if current track is "Raining Tacos"
    if (track.id === 'tacos-1' || track.title.toLowerCase().includes('raining tacos')) {
      this.startTacosRain();
    } else {
      this.stopTacosRain();
    }
  }

  private startTacosRain(): void {
    if (this.tacosRainInterval) return; // Already running

    const container = document.getElementById('tacos-rain-container');
    if (!container) return;

    container.classList.remove('hidden');
    
    // Create tacos at intervals
    this.tacosRainInterval = window.setInterval(() => {
      this.createTaco();
    }, 250); // Create a new taco every 250ms (even faster rain!)

    console.log('üåÆ It\'s raining tacos everywhere! üåÆ');
  }

  private stopTacosRain(): void {
    if (this.tacosRainInterval) {
      clearInterval(this.tacosRainInterval);
      this.tacosRainInterval = null;
    }

    const container = document.getElementById('tacos-rain-container');
    if (container) {
      container.classList.add('hidden');
      // Clean up existing tacos
      this.activeTacos.forEach(taco => {
        if (taco.parentNode) {
          taco.parentNode.removeChild(taco);
        }
      });
      this.activeTacos = [];
    }

    console.log('üåÆ Tacos rain stopped');
  }

  private createTaco(): void {
    const container = document.getElementById('tacos-rain-container');
    if (!container) return;

    const taco = document.createElement('div');
    taco.className = 'taco-falling';
    
    // Random taco emoji variations
    const tacoEmojis = ['üåÆ', 'üåØ', 'ü•ô', 'üåÆ', 'üåÆ', 'üåÆ']; // More tacos!
    taco.textContent = tacoEmojis[Math.floor(Math.random() * tacoEmojis.length)];
    
    // Random horizontal position across full screen width
    const screenWidth = window.innerWidth;
    const leftPosition = Math.random() * (screenWidth - 50); // Leave some margin
    taco.style.left = `${leftPosition}px`;
    taco.style.position = 'absolute';
    
    // Random animation duration (3-6 seconds for full fall)
    const duration = 3 + Math.random() * 3;
    taco.style.animationDuration = `${duration}s`;
    taco.style.animationName = 'tacoFallWithDrift';
    
    // Random rotation
    const rotation = Math.random() * 360;
    taco.style.setProperty('--rotation', `${rotation}deg`);
    
    // Random size variation
    const scale = 0.7 + Math.random() * 0.9; // 0.7 to 1.6
    taco.style.setProperty('--scale', scale.toString());
    
    // Random horizontal drift
    const drift = (Math.random() - 0.5) * 150; // -75px to +75px drift
    taco.style.setProperty('--drift', `${drift}px`);
    
    container.appendChild(taco);
    this.activeTacos.push(taco);
    
    // Remove taco after animation completes + buffer
    setTimeout(() => {
      if (taco.parentNode) {
        taco.parentNode.removeChild(taco);
      }
      const index = this.activeTacos.indexOf(taco);
      if (index > -1) {
        this.activeTacos.splice(index, 1);
      }
    }, (duration + 1) * 1000); // Add 1 second buffer
  }

  // Cleanup method
  public destroy(): void {
    this.stopProgressTracking();
    this.stopTacosRain();
    
    // Clear mobile-specific timeouts
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
    }
    
    if (this.currentSound) {
      this.currentSound.stop();
      this.currentSound.unload();
    }
    
    console.log('üßπ Music player cleaned up');
  }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  try {
    // Check if Howler is loaded
    if (typeof Howl === 'undefined') {
      console.error('‚ùå Howler.js not loaded');
      return;
    }
    
    const musicPlayer = new HowlerMusicPlayer();
    
    // Global access for debugging
    (window as any).musicPlayer = musicPlayer;
    
    console.log('‚úÖ Howler Music Player Ready');
    console.log('üí° Replace demo URLs in playlist with your audio files');
    console.log('üì± Mobile optimizations enabled');
    
  } catch (error) {
    console.error('Failed to initialize Howler music player:', error);
  }
});
</script>

<style>
  :root {
    --music-primary: #8b5cf6;
    --music-secondary: #ec4899;
    --music-bg: rgba(255, 255, 255, 0.95);
    --music-bg-dark: rgba(31, 41, 55, 0.95);
    --music-text: #1f2937;
    --music-text-dark: #f9fafb;
    --music-text-muted: #6b7280;
    --music-text-muted-dark: #9ca3af;
    --music-border: rgba(255, 255, 255, 0.2);
    --music-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    --music-backdrop: blur(16px);
    --music-transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  /* Mobile-first optimizations */
  @media (max-width: 768px) {
    .music-panel {
      /* Prevent interference with scroll */
      will-change: auto;
      backface-visibility: hidden;
      transform: translateZ(0);
    }
    
    .taco-falling {
      /* Optimize animations for mobile */
      will-change: transform;
      backface-visibility: hidden;
    }
  }

  .music-toggle-btn {
    @apply w-14 h-14 rounded-full shadow-lg flex items-center justify-center text-white relative;
    @apply hover:scale-110 focus:scale-110 focus:outline-none focus:ring-4 focus:ring-purple-500/30;
    @apply transition-all duration-300 ease-out;
    background: linear-gradient(135deg, var(--music-primary), var(--music-secondary));
    /* Mobile touch optimization */
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }

  .music-panel {
    @apply absolute bottom-16 right-0 w-80 rounded-2xl p-6 border backdrop-blur-lg;
    @apply transition-all duration-300 ease-out transform;
    background: var(--music-bg);
    border-color: var(--music-border);
    box-shadow: var(--music-shadow);
    backdrop-filter: var(--music-backdrop);
    /* Mobile optimizations */
    touch-action: manipulation;
    -webkit-overflow-scrolling: touch;
  }

  .dark .music-panel {
    background: var(--music-bg-dark);
  }

  .music-panel--closed {
    @apply opacity-0 pointer-events-none translate-y-4 scale-95;
    visibility: hidden;
  }

  .music-panel--open {
    @apply opacity-100 pointer-events-auto translate-y-0 scale-100;
    visibility: visible;
  }

  .song-info {
    @apply flex items-center gap-4 mb-6;
  }

  .album-art {
    @apply w-12 h-12 rounded-lg flex items-center justify-center flex-shrink-0;
    background: linear-gradient(135deg, var(--music-primary), var(--music-secondary));
  }

  .song-details {
    @apply flex-1 min-w-0;
  }

  .song-title {
    @apply font-semibold text-base truncate mb-1;
    color: var(--music-text);
  }

  .dark .song-title {
    color: var(--music-text-dark);
  }

  .song-artist {
    @apply text-sm truncate;
    color: var(--music-text-muted);
  }

  .dark .song-artist {
    color: var(--music-text-muted-dark);
  }

  .progress-section {
    @apply mb-6;
  }

  .time-display {
    @apply flex items-center justify-between text-xs mb-2;
    color: var(--music-text-muted);
  }

  .dark .time-display {
    color: var(--music-text-muted-dark);
  }

  .time-text {
    @apply font-mono;
  }

  .progress-container {
    @apply w-full h-3 bg-gray-200 dark:bg-gray-700 rounded-full cursor-pointer relative;
    @apply focus:outline-none focus:ring-2 focus:ring-purple-500/50;
    @apply transition-all duration-200;
    /* Mobile touch optimization */
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }

  .progress-container:hover {
    @apply bg-gray-300 dark:bg-gray-600;
  }

  .progress-bar {
    @apply h-full rounded-full transition-all duration-300 relative;
    background: linear-gradient(90deg, var(--music-primary), var(--music-secondary));
    width: 0%;
  }

  .progress-bar::after {
    content: '';
    @apply absolute right-0 top-1/2 w-3 h-3 bg-white rounded-full shadow-md;
    @apply transform -translate-y-1/2 translate-x-1/2 opacity-0 transition-opacity duration-200;
  }

  .progress-container:hover .progress-bar::after,
  .progress-container:focus .progress-bar::after {
    @apply opacity-100;
  }

  .controls-section {
    @apply flex items-center justify-center gap-4 mb-6;
  }

  .control-btn {
    @apply w-10 h-10 flex items-center justify-center rounded-full;
    @apply hover:bg-gray-100 dark:hover:bg-gray-700 focus:bg-gray-100 dark:focus:bg-gray-700;
    @apply focus:outline-none focus:ring-2 focus:ring-purple-500/50;
    @apply transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed;
    color: var(--music-text-muted);
    /* Mobile touch optimization */
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }

  .dark .control-btn {
    color: var(--music-text-muted-dark);
  }

  .control-btn:not(:disabled):hover,
  .control-btn:not(:disabled):focus {
    color: var(--music-primary);
  }

  .play-pause-btn {
    @apply w-12 h-12 rounded-full flex items-center justify-center text-white relative;
    @apply hover:scale-105 focus:scale-105 focus:outline-none focus:ring-4 focus:ring-purple-500/30;
    @apply transition-all duration-200;
    background: linear-gradient(135deg, var(--music-primary), var(--music-secondary));
    /* Mobile touch optimization */
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }

  .play-pause-btn:hover,
  .play-pause-btn:focus {
    box-shadow: 0 10px 25px -5px rgba(139, 92, 246, 0.4);
  }

  .volume-section {
    @apply flex items-center gap-3 mb-4;
  }

  .volume-icon {
    @apply w-4 h-4 flex-shrink-0;
    color: var(--music-text-muted);
  }

  .dark .volume-icon {
    color: var(--music-text-muted-dark);
  }

  .volume-slider {
    @apply flex-1 h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer;
    @apply focus:outline-none focus:ring-2 focus:ring-purple-500/50;
    @apply transition-all duration-200;
    /* Mobile touch optimization */
    touch-action: manipulation;
  }

  .volume-slider::-webkit-slider-thumb {
    @apply appearance-none w-4 h-4 rounded-full cursor-pointer;
    @apply transition-all duration-200 hover:scale-110;
    background: linear-gradient(135deg, var(--music-primary), var(--music-secondary));
    box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
  }

  .volume-slider::-moz-range-thumb {
    @apply w-4 h-4 rounded-full cursor-pointer border-0;
    @apply transition-all duration-200;
    background: linear-gradient(135deg, var(--music-primary), var(--music-secondary));
    box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
  }

  .volume-slider::-webkit-slider-track {
    @apply bg-gray-200 dark:bg-gray-700 h-2 rounded-lg;
  }

  .volume-slider::-moz-range-track {
    @apply bg-gray-200 dark:bg-gray-700 h-2 rounded-lg border-0;
  }

  .status-section {
    @apply text-center;
  }

  .status-text {
    @apply text-xs font-medium;
    color: var(--music-text-muted);
  }

  .dark .status-text {
    color: var(--music-text-muted-dark);
  }

  .music-toast {
    @apply fixed bottom-20 right-4 bg-gray-900 dark:bg-gray-800 text-white;
    @apply px-4 py-3 rounded-lg shadow-lg z-50 text-sm max-w-xs;
    @apply animate-slide-up opacity-0;
    animation: slideUpFade 0.3s ease-out forwards, fadeOut 0.3s ease-out 3.7s forwards;
  }

  .sr-only {
    @apply absolute w-px h-px p-0 -m-px overflow-hidden whitespace-nowrap border-0;
    clip: rect(0, 0, 0, 0);
  }

  @keyframes slideUpFade {
    from {
      transform: translateY(1rem);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  @keyframes fadeOut {
    from {
      opacity: 1;
    }
    to {
      opacity: 0;
    }
  }

  .play-pause-btn[data-state="playing"]::before {
    content: "";
    @apply absolute inset-0 rounded-full;
    background: linear-gradient(135deg, var(--music-primary), var(--music-secondary));
    animation: ripple 2s ease-out infinite;
    z-index: -1;
  }

  @keyframes ripple {
    0% {
      transform: scale(1);
      opacity: 1;
    }
    100% {
      transform: scale(1.2);
      opacity: 0;
    }
  }

  @media (max-width: 640px) {
    .music-panel {
      @apply w-72 right-2;
    }
    
    .music-toggle-btn {
      @apply w-12 h-12;
    }
    
    .music-toggle-btn svg {
      @apply w-5 h-5;
    }
    
    /* Improved mobile touch targets */
    .control-btn {
      @apply w-12 h-12;
      min-height: 44px;
      min-width: 44px;
    }
    
    .progress-container {
      @apply h-4;
      min-height: 44px;
      padding: 20px 0;
    }
    
    .volume-slider {
      @apply h-3;
      min-height: 44px;
      padding: 20px 0;
    }
  }

  #music-panel {
    opacity: 0 !important;
    pointer-events: none !important;
    visibility: hidden !important;
    transform: translateY(1rem) scale(0.95) !important;
  }

  #music-panel.music-panel--open {
    opacity: 1 !important;
    pointer-events: auto !important;
    visibility: visible !important;
    transform: translateY(0) scale(1) !important;
  }

  /* Tacos Rain Animation Styles - Mobile Optimized */
  .tacos-rain-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 40;
    overflow: hidden;
    /* Mobile performance optimization */
    will-change: auto;
    backface-visibility: hidden;
    transform: translateZ(0);
  }

  .tacos-rain-container.hidden {
    display: none;
  }

  .taco-falling {
    position: absolute;
    top: -100px;
    font-size: calc(32px * var(--scale, 1));
    line-height: 1;
    pointer-events: none;
    user-select: none;
    animation: tacoFallWithDrift linear forwards;
    transform: rotate(var(--rotation, 0deg));
    z-index: 41;
    text-shadow: 2px 2px 6px rgba(0,0,0,0.5);
    filter: drop-shadow(0 0 8px rgba(255, 193, 7, 0.3));
    /* Mobile performance optimization */
    will-change: transform;
    backface-visibility: hidden;
  }

  @keyframes tacoFallWithDrift {
    0% {
      transform: translateY(-80px) translateX(0) rotate(var(--rotation, 0deg)) scale(var(--scale, 1));
      opacity: 0;
    }
    5% {
      opacity: 1;
    }
    95% {
      opacity: 1;
    }
    100% {
      transform: 
        translateY(calc(100vh + 120px)) 
        translateX(var(--drift, 0px)) 
        rotate(calc(var(--rotation, 0deg) + 360deg)) 
        scale(var(--scale, 1));
      opacity: 0;
    }
  }

  /* Add some sparkle/glitter effect */
  .taco-falling::before {
    content: '‚ú®';
    position: absolute;
    top: -10px;
    right: -10px;
    font-size: 12px;
    animation: sparkle 1s ease-in-out infinite alternate;
  }

  .taco-falling::after {
    content: 'üí´';
    position: absolute;
    bottom: -10px;
    left: -10px;
    font-size: 10px;
    animation: sparkle 1.5s ease-in-out infinite alternate-reverse;
  }

  @keyframes sparkle {
    0% {
      opacity: 0.3;
      transform: scale(0.8);
    }
    100% {
      opacity: 1;
      transform: scale(1.2);
    }
  }

  /* Enhanced background effect when tacos are raining */
  .tacos-rain-container:not(.hidden)::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(
      180deg,
      rgba(255, 193, 7, 0.05) 0%,
      rgba(255, 152, 0, 0.03) 50%,
      rgba(255, 87, 34, 0.02) 100%
    );
    pointer-events: none;
    z-index: 39;
  }

  /* Add some floating taco clouds */
  .tacos-rain-container:not(.hidden)::after {
    content: '‚òÅÔ∏èüåÆ ‚òÅÔ∏èüåØ ‚òÅÔ∏èü•ô ‚òÅÔ∏èüåÆ';
    position: fixed;
    top: 10px;
    left: 0;
    width: 100vw;
    text-align: center;
    font-size: 20px;
    opacity: 0.8;
    animation: float 4s ease-in-out infinite;
    pointer-events: none;
    z-index: 40;
    letter-spacing: 40px;
  }

  @keyframes float {
    0%, 100% {
      transform: translateY(0px);
    }
    50% {
      transform: translateY(-10px);
    }
  }

  /* Reduce motion for users who prefer it */
  @media (prefers-reduced-motion: reduce) {
    .taco-falling,
    .taco-falling::before,
    .taco-falling::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
    
    .music-toggle-btn,
    .play-pause-btn,
    .control-btn {
      transition: none !important;
    }
  }
</style>