---
// Fixed music player with proper autoplay handling
---

<div class="fixed bottom-4 right-4 z-50" id="music-player-container">
  <!-- Toggle Button with visual indicator -->
  <button
    id="music-toggle"
    type="button"
    class="music-toggle-btn"
    aria-label="Toggle music player"
    aria-expanded="false"
    aria-controls="music-panel"
  >
    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
    </svg>
    <!-- Playing indicator -->
    <div id="playing-indicator" class="absolute -top-1 -right-1 w-3 h-3 bg-green-500 rounded-full animate-pulse hidden"></div>
    <span class="sr-only">Music Player</span>
  </button>

  <!-- Music Player Panel -->
  <div
    id="music-panel"
    class="music-panel music-panel--closed"
    role="dialog"
    aria-label="Music player controls"
    aria-hidden="true"
  >
    <!-- Current Song Info -->
    <div class="song-info">
      <div class="album-art">
        <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
        </svg>
      </div>
      <div class="song-details">
        <h4 id="song-title" class="song-title" aria-live="polite">
          Click play to start
        </h4>
        <p id="song-artist" class="song-artist" aria-live="polite">
          Music ready
        </p>
      </div>
    </div>

    <!-- Progress Section -->
    <div class="progress-section">
      <div class="time-display">
        <time id="current-time" class="time-text">0:00</time>
        <time id="total-time" class="time-text">0:00</time>
      </div>
      <div 
        id="progress-container" 
        class="progress-container"
        role="slider"
        aria-label="Seek position"
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow="0"
        tabindex="0"
      >
        <div id="progress-bar" class="progress-bar"></div>
      </div>
    </div>

    <!-- Control Buttons -->
    <div class="controls-section" role="group" aria-label="Playback controls">
      <button
        id="prev-btn"
        type="button"
        class="control-btn"
        aria-label="Previous track"
      >
        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
        </svg>
      </button>

      <button
        id="play-pause-btn"
        type="button"
        class="play-pause-btn"
        aria-label="Play music"
        data-state="paused"
      >
        <svg id="play-icon" class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M8 5v14l11-7z"/>
        </svg>
        <svg id="pause-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
        </svg>
      </button>

      <button
        id="next-btn"
        type="button"
        class="control-btn"
        aria-label="Next track"
      >
        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
        </svg>
      </button>
    </div>

    <!-- Volume Control -->
    <div class="volume-section">
      <label for="volume-slider" class="sr-only">Volume control</label>
      <svg class="volume-icon" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
      </svg>
      <input
        type="range"
        id="volume-slider"
        class="volume-slider"
        min="0"
        max="100"
        value="50"
        step="1"
        aria-label="Volume"
      />
    </div>

    <!-- Status Display -->
    <div class="status-section">
      <span id="music-status" class="status-text" aria-live="polite" aria-atomic="true">
        Ready to play
      </span>
    </div>

    <!-- Autoplay Info -->
    <div id="autoplay-info" class="text-xs text-center mt-2 text-gray-500 dark:text-gray-400 hidden">
      Click play button to start music
    </div>
  </div>
</div>

<!-- Audio Element -->
<audio 
  id="audio-player"
  preload="metadata"
  crossorigin="anonymous"
  aria-hidden="true"
></audio>

<script>
  // Declare window type extension
  declare global {
    interface Window {
      checkAudioFiles: () => Promise<void>;
    }
  }

  interface Track {
    readonly id: string;
    readonly title: string;
    readonly artist: string;
    readonly src: string;
    readonly duration?: number;
  }

  interface PlayerState {
    isPlaying: boolean;
    currentTrackIndex: number;
    volume: number;
    currentTime: number;
    duration: number;
    isLoading: boolean;
    hasError: boolean;
    isPanelOpen: boolean;
    userHasInteracted: boolean; // Track user interaction for autoplay
    autoplayAttempted: boolean;
  }

  class MusicPlayer {
    private readonly audio: HTMLAudioElement;
    private readonly elements: Map<string, Element | null> = new Map();
    private readonly eventAbortController = new AbortController();
    private state: PlayerState;
    
    // Configuration
    private readonly config = {
      autoplay: true,
      startWithFirstClick: true,
      volume: 50,
      showAutoplayInfo: true,
      isMobile: /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)
    };
    
    private readonly playlist: readonly Track[] = [
      {
        id: 'tacos-1',
        title: 'Raining Tacos',
        artist: 'Parry Gripp & BooneBum',
        src: '/music/raining-tacos.mp3',
        duration: 180
      },
      {
        id: 'lofi-1',
        title: 'Lofi Hip Hop Beat',
        artist: 'Chill Vibes',
        src: '/music/lofi-beat.mp3',
        duration: 180
      }
    ];

    constructor() {
      const audioElement = document.getElementById('audio-player');
      if (!audioElement || !(audioElement instanceof HTMLAudioElement)) {
        throw new Error('Audio element not found');
      }
      this.audio = audioElement;

      // Initialize state
      this.state = {
        isPlaying: false,
        currentTrackIndex: 0,
        volume: this.config.volume,
        currentTime: 0,
        duration: 0,
        isLoading: false,
        hasError: false,
        isPanelOpen: false,
        userHasInteracted: false,
        autoplayAttempted: false
      };

      this.init();
    }

    private async init(): Promise<void> {
      try {
        this.cacheElements();
        this.setupEventListeners();
        this.setupAudioEventListeners();
        this.setupAutoplayDetection();
        
        // Set initial volume
        this.audio.volume = this.state.volume / 100;
        
        // Try to load first track
        await this.loadTrack(this.state.currentTrackIndex);
        
        this.updateUI();
        this.ensurePanelClosed();
        
        // Show autoplay info if needed
        if (this.config.showAutoplayInfo) {
          this.showAutoplayInfo();
        }
        
      } catch (error) {
        console.error('Failed to initialize music player:', error);
        this.handleError('Failed to initialize player');
      }
    }

    private setupAutoplayDetection(): void {
      // Track any user interaction to enable autoplay
      const userInteractionEvents = ['click', 'keydown', 'touchstart', 'touchend'];
      
      const handleUserInteraction = () => {
        if (!this.state.userHasInteracted) {
          this.state.userHasInteracted = true;
          this.hideAutoplayInfo();
          
          // Attempt autoplay if configured and not already attempted
          if (this.config.autoplay && !this.state.autoplayAttempted) {
            this.attemptAutoplay();
          }
        }
      };

      userInteractionEvents.forEach(event => {
        document.addEventListener(event, handleUserInteraction, { 
          once: true, 
          signal: this.eventAbortController.signal 
        });
      });

      // Tambahan untuk mobile: coba autoplay setelah interaksi pertama
      if (this.config.isMobile) {
        document.addEventListener('touchstart', () => {
          if (!this.state.autoplayAttempted && this.config.autoplay) {
            this.attemptAutoplay();
          }
        }, { once: true, signal: this.eventAbortController.signal });
      }
    }

    private async attemptAutoplay(): Promise<void> {
      if (this.state.autoplayAttempted || this.state.isPlaying) return;
      
      this.state.autoplayAttempted = true;
      
      try {
        // Untuk mobile, tunggu sedikit lebih lama
        const delay = this.config.isMobile ? 500 : 100;
        await new Promise(resolve => setTimeout(resolve, delay));
        
        // Set volume ke 0 dulu untuk menghindari suara keras
        const originalVolume = this.audio.volume;
        this.audio.volume = 0;
        
        await this.play();
        
        // Kembalikan volume secara bertahap
        if (this.state.isPlaying) {
          this.audio.volume = originalVolume;
          this.updateStatus('Auto-playing...');
          this.showPlayingIndicator();
        }
        
      } catch (error) {
        console.warn('Autoplay failed:', error);
        this.updateStatus('Click play to start');
        this.showAutoplayInfo();
      }
    }

    private cacheElements(): void {
      const elementIds = [
        'music-toggle', 'music-panel', 'song-title', 'song-artist',
        'current-time', 'total-time', 'progress-container', 'progress-bar',
        'prev-btn', 'play-pause-btn', 'next-btn', 'volume-slider',
        'music-status', 'play-icon', 'pause-icon', 'playing-indicator',
        'autoplay-info'
      ];

      elementIds.forEach(id => {
        this.elements.set(id, document.getElementById(id));
      });
    }

    private setupEventListeners(): void {
      const { signal } = this.eventAbortController;

      // Panel toggle
      this.addEventListenerSafely('music-toggle', 'click', () => {
        this.togglePanel();
      }, { signal });

      // Play/Pause with user interaction tracking
      this.addEventListenerSafely('play-pause-btn', 'click', async (e) => {
        e.preventDefault();
        
        // Mark user interaction
        this.state.userHasInteracted = true;
        this.hideAutoplayInfo();
        
        await this.togglePlayback();
      }, { signal });

      // Navigation
      this.addEventListenerSafely('prev-btn', 'click', () => {
        this.previousTrack();
      }, { signal });

      this.addEventListenerSafely('next-btn', 'click', () => {
        this.nextTrack();
      }, { signal });

      // Volume
      this.addEventListenerSafely('volume-slider', 'input', (e) => {
        const target = e.target as HTMLInputElement;
        this.setVolume(Number(target.value));
      }, { signal });

      // Progress
      this.addEventListenerSafely('progress-container', 'click', (e) => {
        this.handleProgressClick(e as MouseEvent);
      }, { signal });

      // Outside click
      document.addEventListener('click', (e) => {
        this.handleOutsideClick(e);
      }, { signal });
    }

    private setupAudioEventListeners(): void {
      const { signal } = this.eventAbortController;
      
      this.audio.addEventListener('loadstart', () => {
        this.state.isLoading = true;
        this.updateStatus('Loading...');
      }, { signal });

      this.audio.addEventListener('loadedmetadata', () => {
        this.handleLoadedMetadata();
      }, { signal });

      this.audio.addEventListener('canplay', () => {
        this.state.isLoading = false;
        this.updateStatus('Ready to play');
      }, { signal });

      this.audio.addEventListener('timeupdate', () => {
        this.handleTimeUpdate();
      }, { signal });

      this.audio.addEventListener('ended', () => {
        this.handleTrackEnded();
      }, { signal });

      this.audio.addEventListener('error', (e) => {
        this.handleAudioError(e);
      }, { signal });

      this.audio.addEventListener('play', () => {
        this.state.isPlaying = true;
        this.updatePlayButton();
        this.showPlayingIndicator();
        this.updateStatus('Playing');
      }, { signal });

      this.audio.addEventListener('pause', () => {
        this.state.isPlaying = false;
        this.updatePlayButton();
        this.hidePlayingIndicator();
        this.updateStatus('Paused');
      }, { signal });
    }

    private async loadTrack(index: number): Promise<void> {
      if (index < 0 || index >= this.playlist.length) {
        throw new Error(`Invalid track index: ${index}`);
      }

      const track = this.playlist[index];
      this.state.currentTrackIndex = index;
      this.state.hasError = false;

      try {
        // Reset audio
        this.audio.pause();
        this.audio.currentTime = 0;
        this.audio.src = track.src;
        this.audio.volume = this.state.volume / 100;

        // Update UI
        this.updateTrackInfo(track);
        
        // Load the track
        this.audio.load();
        
      } catch (error) {
        console.error('Failed to load track:', error);
        this.handleError(`Failed to load: ${track.title}`);
      }
    }

    private async togglePlayback(): Promise<void> {
      try {
        if (this.state.isPlaying) {
          await this.pause();
        } else {
          await this.play();
        }
      } catch (error) {
        console.error('Playback toggle failed:', error);
        this.handleError('Playback failed - check audio file exists');
      }
    }

    private async play(): Promise<void> {
      if (this.state.hasError) {
        await this.loadTrack(this.state.currentTrackIndex);
      }

      try {
        const playPromise = this.audio.play();
        
        if (playPromise !== undefined) {
          await playPromise;
          this.state.isPlaying = true;
        }
      } catch (error) {
        console.error('Play failed:', error);
        
        if (error instanceof DOMException) {
          switch (error.name) {
            case 'NotAllowedError':
              this.updateStatus('Click to enable audio');
              this.showAutoplayInfo();
              break;
            case 'NotSupportedError':
              this.handleError('Audio format not supported');
              break;
            case 'AbortError':
              this.updateStatus('Playback interrupted');
              break;
            default:
              this.handleError('Playback failed');
          }
        }
        throw error;
      }
    }

    private async pause(): Promise<void> {
      this.audio.pause();
      this.state.isPlaying = false;
    }

    private async previousTrack(): Promise<void> {
      const newIndex = this.state.currentTrackIndex > 0 
        ? this.state.currentTrackIndex - 1 
        : this.playlist.length - 1;
      
      await this.loadTrack(newIndex);
      
      if (this.state.userHasInteracted && this.state.isPlaying) {
        await this.play();
      }
    }

    private async nextTrack(): Promise<void> {
      const newIndex = (this.state.currentTrackIndex + 1) % this.playlist.length;
      await this.loadTrack(newIndex);
      
      if (this.state.userHasInteracted && this.state.isPlaying) {
        await this.play();
      }
    }

    private setVolume(volume: number): void {
      const clampedVolume = Math.max(0, Math.min(100, volume));
      this.state.volume = clampedVolume;
      this.audio.volume = clampedVolume / 100;
      
      localStorage.setItem('musicPlayerVolume', clampedVolume.toString());
    }

    // UI Methods
    private updateTrackInfo(track: Track): void {
      const titleEl = this.elements.get('song-title') as HTMLElement;
      const artistEl = this.elements.get('song-artist') as HTMLElement;
      
      if (titleEl) titleEl.textContent = track.title;
      if (artistEl) artistEl.textContent = track.artist;
    }

    private updatePlayButton(): void {
      const playBtn = this.elements.get('play-pause-btn') as HTMLButtonElement;
      const playIcon = this.elements.get('play-icon') as HTMLElement;
      const pauseIcon = this.elements.get('pause-icon') as HTMLElement;
      
      if (!playBtn || !playIcon || !pauseIcon) return;
      
      const isPlaying = this.state.isPlaying;
      
      playBtn.setAttribute('aria-label', isPlaying ? 'Pause' : 'Play');
      playBtn.setAttribute('data-state', isPlaying ? 'playing' : 'paused');
      
      playIcon.classList.toggle('hidden', isPlaying);
      pauseIcon.classList.toggle('hidden', !isPlaying);
    }

    private updateProgress(): void {
      if (!this.state.duration) return;
      
      const percentage = (this.state.currentTime / this.state.duration) * 100;
      const progressBar = this.elements.get('progress-bar') as HTMLElement;
      const currentTimeEl = this.elements.get('current-time') as HTMLElement;
      
      if (progressBar) {
        progressBar.style.width = `${percentage}%`;
      }
      
      if (currentTimeEl) {
        currentTimeEl.textContent = this.formatTime(this.state.currentTime);
      }
    }

    private updateStatus(message: string): void {
      const statusEl = this.elements.get('music-status') as HTMLElement;
      if (statusEl) {
        statusEl.textContent = message;
      }
    }

    private updateUI(): void {
      this.updateTrackInfo(this.playlist[this.state.currentTrackIndex]);
      this.updatePlayButton();
      this.updateProgress();
      const volumeSlider = this.elements.get('volume-slider') as HTMLInputElement;
      if (volumeSlider) {
        volumeSlider.value = this.state.volume.toString();
      }
    }

    private showPlayingIndicator(): void {
      const indicator = this.elements.get('playing-indicator') as HTMLElement;
      if (indicator) {
        indicator.classList.remove('hidden');
      }
    }

    private hidePlayingIndicator(): void {
      const indicator = this.elements.get('playing-indicator') as HTMLElement;
      if (indicator) {
        indicator.classList.add('hidden');
      }
    }

    private showAutoplayInfo(): void {
      const info = this.elements.get('autoplay-info') as HTMLElement;
      if (info && this.config.showAutoplayInfo) {
        info.textContent = this.config.isMobile 
          ? 'Tap anywhere to enable audio'
          : 'Click play button to start music';
        info.classList.remove('hidden');
      }
    }

    private hideAutoplayInfo(): void {
      const info = this.elements.get('autoplay-info') as HTMLElement;
      if (info) {
        info.classList.add('hidden');
      }
    }

    // Event Handlers
    private handleLoadedMetadata(): void {
      this.state.duration = this.audio.duration || 0;
      this.state.isLoading = false;
      
      const totalTimeEl = this.elements.get('total-time') as HTMLElement;
      if (totalTimeEl) {
        totalTimeEl.textContent = this.formatTime(this.state.duration);
      }
    }

    private handleTimeUpdate(): void {
      this.state.currentTime = this.audio.currentTime;
      this.updateProgress();
    }

    private async handleTrackEnded(): Promise<void> {
      this.state.isPlaying = false;
      this.updatePlayButton();
      this.hidePlayingIndicator();
      
      // Auto-advance to next track if user has interacted
      if (this.state.userHasInteracted) {
        await this.nextTrack();
      }
    }

    private handleAudioError(e: Event): void {
      console.error('Audio error:', e);
      this.state.hasError = true;
      this.state.isPlaying = false;
      this.state.isLoading = false;
      this.updatePlayButton();
      this.hidePlayingIndicator();
      
      const track = this.playlist[this.state.currentTrackIndex];
      this.handleError(`Failed to load: ${track.title} - Check if file exists`);
    }

    private handleProgressClick(e: MouseEvent): void {
      if (!this.audio.duration) return;

      const container = e.currentTarget as HTMLElement;
      const rect = container.getBoundingClientRect();
      const percentage = (e.clientX - rect.left) / rect.width;
      const newTime = percentage * this.audio.duration;
      
      this.audio.currentTime = Math.max(0, Math.min(this.audio.duration, newTime));
    }

    private handleOutsideClick(e: Event): void {
      const container = this.elements.get('music-player-container') as HTMLElement;
      const target = e.target as Node;
      
      if (container && !container.contains(target) && this.state.isPanelOpen) {
        this.closePanel();
      }
    }

    private handleError(message: string): void {
      this.state.hasError = true;
      this.updateStatus(`Error: ${message}`);
      this.showToast(message);
    }

    // Panel Methods
    private togglePanel(): void {
      if (this.state.isPanelOpen) {
        this.closePanel();
      } else {
        this.openPanel();
      }
    }

    private openPanel(): void {
      const panel = this.elements.get('music-panel') as HTMLElement;
      const toggle = this.elements.get('music-toggle') as HTMLElement;
      
      if (!panel || !toggle) return;
      
      this.state.isPanelOpen = true;
      
      panel.classList.remove('music-panel--closed');
      panel.classList.add('music-panel--open');
      panel.setAttribute('aria-hidden', 'false');
      toggle.setAttribute('aria-expanded', 'true');
    }

    private closePanel(): void {
      const panel = this.elements.get('music-panel') as HTMLElement;
      const toggle = this.elements.get('music-toggle') as HTMLElement;
      
      if (!panel || !toggle) return;
      
      this.state.isPanelOpen = false;
      
      panel.classList.remove('music-panel--open');
      panel.classList.add('music-panel--closed');
      panel.setAttribute('aria-hidden', 'true');
      toggle.setAttribute('aria-expanded', 'false');
    }

    private ensurePanelClosed(): void {
      this.state.isPanelOpen = false;
      this.closePanel();
    }

    // Utility Methods
    private addEventListenerSafely(
      elementId: string, 
      event: string, 
      handler: EventListener, 
      options?: AddEventListenerOptions
    ): void {
      const element = this.elements.get(elementId);
      if (element) {
        element.addEventListener(event, handler, options);
      }
    }

    private formatTime(seconds: number): string {
      if (!seconds || isNaN(seconds)) return '0:00';
      
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    private showToast(message: string): void {
      document.querySelectorAll('.music-toast').forEach(toast => toast.remove());
      
      const toast = document.createElement('div');
      toast.className = 'music-toast';
      toast.textContent = message;
      toast.setAttribute('role', 'alert');
      
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.remove();
      }, 4000);
    }

    // Cleanup
    public destroy(): void {
      this.eventAbortController.abort();
      this.audio.pause();
      this.audio.src = '';
    }
  }

  // Initialize
  document.addEventListener('DOMContentLoaded', () => {
    try {
      const musicPlayer = new MusicPlayer();
      
      // Debug info
      console.log('🎵 Music Player Initialized');
      console.log('📁 Make sure audio files exist in public/music/ folder');
      console.log('🔊 Autoplay requires user interaction in modern browsers');
      
      // Global access for debugging
      if (import.meta.env.DEV) {
        (window as any).musicPlayer = musicPlayer;
      }
    } catch (error) {
      console.error('Failed to initialize music player:', error);
    }
  });
</script>

<!-- Include the same styles from previous version -->
<style>
  /* All the same styles as before... */
  :root {
    --music-primary: #8b5cf6;
    --music-secondary: #ec4899;
    --music-bg: rgba(255, 255, 255, 0.95);
    --music-bg-dark: rgba(31, 41, 55, 0.95);
    --music-text: #1f2937;
    --music-text-dark: #f9fafb;
    --music-text-muted: #6b7280;
    --music-text-muted-dark: #9ca3af;
    --music-border: rgba(255, 255, 255, 0.2);
    --music-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    --music-backdrop: blur(16px);
    --music-transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .music-toggle-btn {
    @apply w-14 h-14 rounded-full shadow-lg flex items-center justify-center text-white relative;
    @apply hover:scale-110 focus:scale-110 focus:outline-none focus:ring-4 focus:ring-purple-500/30;
    @apply transition-all duration-300 ease-out;
    background: linear-gradient(135deg, var(--music-primary), var(--music-secondary));
  }

  .music-panel {
    @apply absolute bottom-16 right-0 w-80 rounded-2xl p-6 border backdrop-blur-lg;
    @apply transition-all duration-300 ease-out transform;
    background: var(--music-bg);
    border-color: var(--music-border);
    box-shadow: var(--music-shadow);
    backdrop-filter: var(--music-backdrop);
  }

  .dark .music-panel {
    background: var(--music-bg-dark);
  }

  .music-panel--closed {
    @apply opacity-0 pointer-events-none translate-y-4 scale-95;
    visibility: hidden;
  }

  .music-panel--open {
    @apply opacity-100 pointer-events-auto translate-y-0 scale-100;
    visibility: visible;
  }

  .song-info {
    @apply flex items-center gap-4 mb-6;
  }

  .album-art {
    @apply w-12 h-12 rounded-lg flex items-center justify-center flex-shrink-0;
    background: linear-gradient(135deg, var(--music-primary), var(--music-secondary));
  }

  .song-details {
    @apply flex-1 min-w-0;
  }

  .song-title {
    @apply font-semibold text-base truncate mb-1;
    color: var(--music-text);
  }

  .dark .song-title {
    color: var(--music-text-dark);
  }

  .song-artist {
    @apply text-sm truncate;
    color: var(--music-text-muted);
  }

  .dark .song-artist {
    color: var(--music-text-muted-dark);
  }

  /* Progress section */
  .progress-section {
    @apply mb-6;
  }

  .time-display {
    @apply flex items-center justify-between text-xs mb-2;
    color: var(--music-text-muted);
  }

  .dark .time-display {
    color: var(--music-text-muted-dark);
  }

  .time-text {
    @apply font-mono;
  }

  .progress-container {
    @apply w-full h-3 bg-gray-200 dark:bg-gray-700 rounded-full cursor-pointer relative;
    @apply focus:outline-none focus:ring-2 focus:ring-purple-500/50;
    @apply transition-all duration-200;
  }

  .progress-container:hover {
    @apply bg-gray-300 dark:bg-gray-600;
  }

  .progress-bar {
    @apply h-full rounded-full transition-all duration-300 relative;
    background: linear-gradient(90deg, var(--music-primary), var(--music-secondary));
    width: 0%;
  }

  .progress-bar::after {
    content: '';
    @apply absolute right-0 top-1/2 w-3 h-3 bg-white rounded-full shadow-md;
    @apply transform -translate-y-1/2 translate-x-1/2 opacity-0 transition-opacity duration-200;
  }

  .progress-container:hover .progress-bar::after,
  .progress-container:focus .progress-bar::after {
    @apply opacity-100;
  }

  /* Controls section */
  .controls-section {
    @apply flex items-center justify-center gap-4 mb-6;
  }

  .control-btn {
    @apply w-10 h-10 flex items-center justify-center rounded-full;
    @apply hover:bg-gray-100 dark:hover:bg-gray-700 focus:bg-gray-100 dark:focus:bg-gray-700;
    @apply focus:outline-none focus:ring-2 focus:ring-purple-500/50;
    @apply transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed;
    color: var(--music-text-muted);
  }

  .dark .control-btn {
    color: var(--music-text-muted-dark);
  }

  .control-btn:not(:disabled):hover,
  .control-btn:not(:disabled):focus {
    color: var(--music-primary);
  }

  .play-pause-btn {
    @apply w-12 h-12 rounded-full flex items-center justify-center text-white relative;
    @apply hover:scale-105 focus:scale-105 focus:outline-none focus:ring-4 focus:ring-purple-500/30;
    @apply transition-all duration-200;
    background: linear-gradient(135deg, var(--music-primary), var(--music-secondary));
  }

  .play-pause-btn:hover,
  .play-pause-btn:focus {
    box-shadow: 0 10px 25px -5px rgba(139, 92, 246, 0.4);
  }

  /* Volume section */
  .volume-section {
    @apply flex items-center gap-3 mb-4;
  }

  .volume-icon {
    @apply w-4 h-4 flex-shrink-0;
    color: var(--music-text-muted);
  }

  .dark .volume-icon {
    color: var(--music-text-muted-dark);
  }

  .volume-slider {
    @apply flex-1 h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer;
    @apply focus:outline-none focus:ring-2 focus:ring-purple-500/50;
    @apply transition-all duration-200;
  }

  .volume-slider::-webkit-slider-thumb {
    @apply appearance-none w-4 h-4 rounded-full cursor-pointer;
    @apply transition-all duration-200 hover:scale-110;
    background: linear-gradient(135deg, var(--music-primary), var(--music-secondary));
    box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
  }

  .volume-slider::-moz-range-thumb {
    @apply w-4 h-4 rounded-full cursor-pointer border-0;
    @apply transition-all duration-200;
    background: linear-gradient(135deg, var(--music-primary), var(--music-secondary));
    box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
  }

  .volume-slider::-webkit-slider-track {
    @apply bg-gray-200 dark:bg-gray-700 h-2 rounded-lg;
  }

  .volume-slider::-moz-range-track {
    @apply bg-gray-200 dark:bg-gray-700 h-2 rounded-lg border-0;
  }

  /* Status section */
  .status-section {
    @apply text-center;
  }

  .status-text {
    @apply text-xs font-medium;
    color: var(--music-text-muted);
  }

  .dark .status-text {
    color: var(--music-text-muted-dark);
  }

  /* Toast notifications */
  .music-toast {
    @apply fixed bottom-20 right-4 bg-gray-900 dark:bg-gray-800 text-white;
    @apply px-4 py-3 rounded-lg shadow-lg z-50 text-sm max-w-xs;
    @apply animate-slide-up opacity-0;
    animation: slideUpFade 0.3s ease-out forwards, fadeOut 0.3s ease-out 3.7s forwards;
  }

  /* Screen reader only content */
  .sr-only {
    @apply absolute w-px h-px p-0 -m-px overflow-hidden whitespace-nowrap border-0;
    clip: rect(0, 0, 0, 0);
  }

  /* Animations */
  @keyframes slideUpFade {
    from {
      transform: translateY(1rem);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  @keyframes fadeOut {
    from {
      opacity: 1;
    }
    to {
      opacity: 0;
    }
  }

  /* Playing indicator animation */
  .play-pause-btn[data-state="playing"]::before {
    content: "";
    @apply absolute inset-0 rounded-full;
    background: linear-gradient(135deg, var(--music-primary), var(--music-secondary));
    animation: ripple 2s ease-out infinite;
    z-index: -1;
  }

  @keyframes ripple {
    0% {
      transform: scale(1);
      opacity: 1;
    }
    100% {
      transform: scale(1.2);
      opacity: 0;
    }
  }

  /* Mobile responsive */
  @media (max-width: 640px) {
    .music-panel {
      @apply w-72 right-2;
    }
    
    .music-toggle-btn {
      @apply w-12 h-12;
    }
    
    .music-toggle-btn svg {
      @apply w-5 h-5;
    }
  }

  /* Ensure panel starts closed */
  #music-panel {
    opacity: 0 !important;
    pointer-events: none !important;
    visibility: hidden !important;
    transform: translateY(1rem) scale(0.95) !important;
  }

  #music-panel.music-panel--open {
    opacity: 1 !important;
    pointer-events: auto !important;
    visibility: visible !important;
    transform: translateY(0) scale(1) !important;
  }
</style>

<!-- File checker script to help debug missing audio files -->
<script>
  // Debug helper to check if audio files exist
  window.checkAudioFiles = async function() {
    const files = [
      '/music/raining-tacos.mp3',
      '/music/lofi-beat.mp3'
    ];

    console.log('🔍 Checking audio files...');
    
    for (const file of files) {
      try {
        const response = await fetch(file, { method: 'HEAD' });
        if (response.ok) {
          console.log(`✅ ${file} - Found`);
        } else {
          console.log(`❌ ${file} - Not found (${response.status})`);
        }
      } catch (error) {
        console.log(`❌ ${file} - Error: ${(error as Error).message}`);
      }
    }
    
    console.log('💡 To add music files:');
    console.log('1. Create public/music/ folder');
    console.log('2. Add your .mp3 files there');
    console.log('3. Update playlist in MusicPlayer component');
  };

  // Auto-check files on dev mode
  if (import.meta.env.DEV) {
    setTimeout(() => {
      window.checkAudioFiles();
    }, 2000);
  }
</script>